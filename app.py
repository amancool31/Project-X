from flask import Flask, request
from flask_cors import CORS, cross_origin
from flask_restful import Resource, Api
from json import dumps
#from flask_jsonpify import jsonify

import pandas as pd
import datetime
import pandas_datareader.data as web
import math
import pandas as pd
import numpy as np
import preprocessing

from pandas import Series, DataFrame
import yfinance as yf

import matplotlib.pyplot as plt
from matplotlib import style

# Adjusting the size of matplotlib
import matplotlib as mpl

app = Flask(__name__)
api = Api(app)

CORS(app)

from flask import send_file

# http://localhost:5000/get_image?type=1

company = "GE"

df = yf.download(company, start = '2016-01-01', end='2020-03-03')#'2017-01-01')#web.DataReader("AAPL", 'yahoo', start, end)
close_px = df['Adj Close']
mavg = close_px.rolling(window=100).mean()
    
print(mavg)
print(df.head())
print(df.tail())
mpl.rc('figure', figsize=(8, 7))
mpl.__version__

# @app.route('/get_image')
class Q(Resource):
    def get(self):
        

        # Adjusting the style of matplotlib
        style.use('ggplot')

        close_px.plot(label=company)
        mavg.plot(label='mavg')
        # plt.legend()

        
        # p = request.args.get('type')

        plt.savefig('k.png', bbox_inches='tight')
        # if int(p) == 1: 
        k='k.png'


        return send_file(k, mimetype='image/gif')


# @app.route('/get_images')
class w(Resource):
    def get(self):
        
    
        rets = close_px / close_px.shift(1) - 1
        rets.plot(label='return')
        # plt.legend()

        plt.show()

        plt.savefig('q.png', bbox_inches='tight')
        # if int(p) == 2:
        q='q.png'
        return send_file(q, mimetype='image/gif')

# @app.route('/get_return')
class R(Resource):
    def get(self):
        
        dfcomp = yf.download(['AAPL', 'GE', 'GOOG', 'IBM', 'MSFT'],start = '2016-01-01', end='2020-03-28')['Adj Close']

        retscomp = dfcomp.pct_change()

        corr = retscomp.corr()
        plt.imshow(corr, cmap='hot', interpolation='none')
        plt.colorbar()
        plt.xticks(range(len(corr)), corr.columns)
        plt.yticks(range(len(corr)), corr.columns)

        # plt.show()


        plt.savefig('e.png', bbox_inches='tight')
        # if int(p) == 2:
        e='e.png'
        return send_file(e, mimetype='image/gif')


class y(Resource):
    def get(self):
        
            
        from scipy.stats import norm

        # data = yf.download("AAPL", start = '2012-01-01', end='2017-01-01')['Adj Close']


        result=[]
        #Define Variables
        S = yf.download(company, start = '2016-01-01', end='2020-03-28')['Adj Close'][-1]#apple['Adj Close'][-1] #starting stock price (i.e. last available real stock price)
        T = 25 #Number of trading days
        days = (df.index[-1] - df.index[0]).days
        cagr = ((((df['Adj Close'][-1]) / df['Adj Close'][1])) ** (365.0/days)) - 1
        mu = cagr# 0.2309 #Return

        df['Returns'] = df['Adj Close'].pct_change()
        vol = df['Returns'].std()*math.sqrt(252)
        # vol = #0.4259 #Volatility


        #choose number of runs to simulate - I have chosen 10,000
        for i in range(100):
            #create list of daily returns using random normal distribution
            daily_returns=np.random.normal(mu/T,vol/math.sqrt(T),T)+1
            
            #set starting price and create price series generated by above random daily returns
            price_list = [S]
            
            for x in daily_returns:
                price_list.append(price_list[-1]*x)

            plt.plot(price_list)
            
            result.append(price_list[-1])

        #show the plot of multiple price series created above
        # plt.show()
          
        plt.savefig('y.png', bbox_inches='tight')
        # if int(p) == 2:
        y='y.png'
        return send_file(y, mimetype='image/gif')


# @app.route('/add')
class Employees(Resource):
    def get(self):
        #n1 = request.args.get('n1')
        #n2 = request.args.get('n2')
        
        return {'id':1, 'name':'Aman'}#,{'id':2, 'name':'Tom'}] 
        #return str(int(n1)+int(n2))#'Hello, World!'

# api.add_resource(Employees, '/employees') # Route_1
api.add_resource(R, '/r') # Route_1
api.add_resource(w, '/get_images') # Route_1
api.add_resource(Q, '/get_image') # Route_1
# api.add_resource(t, '/prediction') # Route_1
api.add_resource(y, '/monte') # Route_1
# api.add_resource(o, '/dis') # Route_1






if __name__ == '__main__':
    app.run()






# class t(Resource):
#     def get(self):
        
#         import math
#         import numpy as np
#         from sklearn import preprocessing, svm
#         from sklearn.model_selection import train_test_split



#         dfreg = df.loc[:,['Adj Close','Volume']]

#         a=df['High'] - df['Close']
#         print(a)


#         dfreg['HL_PCT'] = a / df['Close'] * 100.0
#         print("yo --- yo ")

#         print(dfreg['HL_PCT'])

#         print(df['Close'])
#         print(df['Open'])

#         b = df['Close'] - df['Open']

#         dfreg['PCT_change'] = b / df['Open'] * 100.0
#         # Drop missing value
#         dfreg.fillna(value=-99999, inplace=True)

#         print(dfreg.shape)
#         # We want to separate 1 percent of the data to forecast
#         forecast_out = int(math.ceil(0.01 * len(dfreg)))

#         # Separating the label here, we want to predict the AdjClose
#         forecast_col = 'Adj Close'
#         dfreg['label'] = dfreg[forecast_col].shift(-forecast_out)
#         X = np.array(dfreg.drop(['label'], 1))

#         # Scale the X so that everyone can have the same distribution for linear regression
#         X = preprocessing.scale(X)

#         # Finally We want to find Data Series of late X and early X (train) for model generation and evaluation
#         X_lately = X[-forecast_out:]
#         X = X[:-forecast_out]

#         # Separate label and identify it as y
#         y = np.array(dfreg['label'])
#         y = y[:-forecast_out]

#         print('Dimension of X',X.shape)
#         print('Dimension of y',y.shape)

#         # Separation of training and testing of model by cross validation train test split
#         X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

#         from sklearn.linear_model import LinearRegression
#         from sklearn.neighbors import KNeighborsRegressor

#         from sklearn.linear_model import Ridge
#         from sklearn.preprocessing import PolynomialFeatures
#         from sklearn.pipeline import make_pipeline

#         # Linear regression
#         clfreg = LinearRegression(n_jobs=-1)
#         clfreg.fit(X_train, y_train)


#         # Quadratic Regression 2
#         clfpoly2 = make_pipeline(PolynomialFeatures(2), Ridge())
#         clfpoly2.fit(X_train, y_train)

#         # Quadratic Regression 3
#         clfpoly3 = make_pipeline(PolynomialFeatures(3), Ridge())
#         clfpoly3.fit(X_train, y_train)
            
#         # KNN Regression
#         clfknn = KNeighborsRegressor(n_neighbors=2)
#         clfknn.fit(X_train, y_train)

#         confidencereg = clfreg.score(X_test, y_test)
#         confidencepoly2 = clfpoly2.score(X_test,y_test)
#         confidencepoly3 = clfpoly3.score(X_test,y_test)
#         confidenceknn = clfknn.score(X_test, y_test)

#         print("The linear regression confidence is ",confidencereg)
#         print("The quadratic regression 2 confidence is ",confidencepoly2)
#         print("The quadratic regression 3 confidence is ",confidencepoly3)
#         print("The knn regression confidence is ",confidenceknn)

#         # Printing the forecast
#         forecast_set = clfreg.predict(X_lately)
#         dfreg['Forecast'] = np.nan
#         print(forecast_set, confidencereg, forecast_out)


#         last_date = dfreg.iloc[-1].name
#         last_unix = last_date
#         next_unix = last_unix + datetime.timedelta(days=1)

#         for i in forecast_set:
#             next_date = next_unix
#             next_unix += datetime.timedelta(days=1)
#             dfreg.loc[next_date] = [np.nan for _ in range(len(dfreg.columns)-1)]+[i]


            
#         dfreg['Adj Close'].tail(500).plot()
#         dfreg['Forecast'].tail(500).plot()
#         plt.legend(loc=4)
#         plt.xlabel('Date')
#         plt.ylabel('Price')
#         # plt.show()

        
#         plt.savefig('t.png', bbox_inches='tight')
#         # if int(p) == 2:
#         t='t.png'
#         return send_file(t, mimetype='image/gif')

